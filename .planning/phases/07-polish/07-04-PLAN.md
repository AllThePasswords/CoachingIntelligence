---
phase: 07-polish
plan: 04
type: execute
wave: 4
depends_on: ["07-03"]
files_modified:
  - src/layouts/AppLayout.jsx
  - src/pages/ManagerDetail/ManagerDetail.jsx
  - src/components/chat/ChatThread/ChatThread.jsx
autonomous: true

must_haves:
  truths:
    - "Error boundaries wrap chat section and show graceful fallback on API errors"
    - "Chat thread uses skeleton during initial loading state"
    - "Buttons and inputs have visible focus rings when keyboard navigated"
  artifacts:
    - path: "src/layouts/AppLayout.jsx"
      provides: "Error boundary around main content area"
      contains: "ErrorBoundary"
    - path: "src/pages/ManagerDetail/ManagerDetail.jsx"
      provides: "Error boundary around chat section"
      contains: "ChatErrorFallback"
  key_links:
    - from: "src/layouts/AppLayout.jsx"
      to: "react-error-boundary"
      via: "import ErrorBoundary"
      pattern: "import.*ErrorBoundary.*from 'react-error-boundary'"
---

<objective>
Wire error boundaries around risky components and add final focus state polish.

Purpose: Ensure graceful degradation when Claude API fails and complete accessibility polish.
Output: Error boundaries in place, focus states applied to remaining interactive elements.
</objective>

<execution_context>
@/Users/ericgreene/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ericgreene/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-polish/07-RESEARCH.md
@src/layouts/AppLayout.jsx
@src/pages/ManagerDetail/ManagerDetail.jsx
@src/components/chat/ChatThread/ChatThread.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error boundary around chat section in ManagerDetail</name>
  <files>src/pages/ManagerDetail/ManagerDetail.jsx</files>
  <action>
Update src/pages/ManagerDetail/ManagerDetail.jsx to wrap the chat section with an error boundary:

1. Add imports at top:
```jsx
import { ErrorBoundary } from 'react-error-boundary';
import { ChatErrorFallback } from '@/components/feedback';
```

2. Find the section that contains ChatThread (the "Ask Anything About {manager.name}" section).

3. Wrap the ChatThread component with ErrorBoundary:
```jsx
<ErrorBoundary
  FallbackComponent={ChatErrorFallback}
  onReset={() => window.location.reload()}
  resetKeys={[managerId]}
>
  <ChatThread onSuggestionClick={sendMessage} />
</ErrorBoundary>
```

The resetKeys prop ensures the boundary resets when navigating to a different manager.
  </action>
  <verify>Intentionally break API call to see ChatErrorFallback render instead of crash</verify>
  <done>Chat section shows friendly error message when ChatThread throws, with retry option</done>
</task>

<task type="auto">
  <name>Task 2: Update ChatThread to use ChatMessageSkeleton during loading</name>
  <files>src/components/chat/ChatThread/ChatThread.jsx</files>
  <action>
Update src/components/chat/ChatThread/ChatThread.jsx to show skeleton during initial loading:

1. Add import at top:
```jsx
import { ChatMessageSkeleton } from '@/components/feedback';
```

2. Update the loading indicator section. Replace or enhance the current loading dots with a more polished state:

Find this section:
```jsx
{/* Loading indicator */}
{status === 'loading' && (
```

Keep the existing loading indicator (bouncing dots with "Analyzing your coaching data...") as it provides good feedback during streaming. The skeleton is more appropriate for initial page load, but since chat starts empty, the current approach is correct.

No change needed here - the existing loading indicator is appropriate for the streaming use case. The skeleton components are available for future use if we add data loading states.
  </action>
  <verify>Loading indicator still shows bouncing dots during Claude API call</verify>
  <done>ChatThread maintains appropriate loading feedback during streaming</done>
</task>

<task type="auto">
  <name>Task 3: Add focus-ring to remaining interactive elements</name>
  <files>src/components/cards/ManagerCard/ManagerCard.jsx, src/components/menus/ActionMenu/ActionMenu.jsx</files>
  <action>
Update focus states on key interactive elements:

1. In src/components/cards/ManagerCard/ManagerCard.jsx:
- Add focus-ring to the bell button:
```jsx
className="... focus-ring"
```
- Add focus-ring to the arrow button:
```jsx
className="... focus-ring"
```
- Make the card itself focusable with visible focus state:
```jsx
<div
  onClick={handleClick}
  tabIndex={0}
  onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') handleClick(); }}
  className="... focus:outline-none focus-visible:ring-2 focus-visible:ring-violet focus-visible:ring-offset-2"
  role="button"
  aria-label={`View details for ${manager.name}`}
>
```

2. In src/components/menus/ActionMenu/ActionMenu.jsx:
- Add focus-ring to the dropdown trigger button
- Add focus-ring to each dropdown menu item
  </action>
  <verify>Tab through dashboard and manager detail page, observe all buttons and cards show focus rings</verify>
  <done>All interactive elements have visible focus indicators for keyboard navigation</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Tab through entire app - all buttons, cards, and inputs show visible focus rings
3. Error boundary works: modify API key to invalid value, ask question, see ChatErrorFallback
4. Click retry in error fallback - page reloads to recover
5. Manager cards are keyboard navigable (Tab to focus, Enter to activate)
</verification>

<success_criteria>
- Error boundary catches chat errors and shows user-friendly fallback
- All interactive elements are keyboard navigable
- Focus states are visible on all focusable elements
- App passes basic keyboard accessibility test (Tab through all interactive elements)
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish/07-04-SUMMARY.md`
</output>
